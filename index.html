<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Interactive Demo - Retro Style with Detailed Trees</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black; /* Black background for retro contrast */
        }
        canvas {
            display: block;
            image-rendering: pixelated; /* Ensures the canvas scales without smoothing */
        }
        #notification {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            font-size: 24px;
            color: #FFFFFF; /* White text for contrast */
            opacity: 0;
            transition: opacity 2s ease-in-out;
            font-family: 'Press Start 2P', cursive; /* Retro font */
            z-index: 20; /* Ensure notification is above other elements */
        }
        #audio-icon {
            position: absolute;
            bottom: 2%;
            right: 2%;
            width: 8%;
            height: auto;
            cursor: pointer;
            z-index: 20; /* Ensure audio icon is above other elements */
        }
        /* Importing retro font */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        /* Touch Controls for Mobile Only */
        @media (max-width: 768px) {
            .touch-control {
                position: absolute;
                background-color: rgba(255, 255, 255, 0.2); /* Semi-transparent white */
                z-index: 10; /* Place controls above canvas but below other UI elements */
                display: flex;
                justify-content: center;
                align-items: center;
                border-radius: 50%;
            }
            #up-arrow {
                bottom: 20%;
                left: 50%;
                transform: translateX(-50%);
                width: 15%;
                height: 15%;
            }
            #down-arrow {
                bottom: 5%;
                left: 50%;
                transform: translateX(-50%);
                width: 15%;
                height: 15%;
            }
            #left-arrow {
                bottom: 12.5%;
                left: 30%;
                transform: translateX(-50%);
                width: 15%;
                height: 15%;
            }
            #right-arrow {
                bottom: 12.5%;
                right: 30%;
                transform: translateX(50%);
                width: 15%;
                height: 15%;
            }
            /* Arrow Images */
            .arrow-image {
                width: 100%;
                height: 100%;
                opacity: 0.8;
            }
        }
    </style>
</head>
<body>
    <div id="notification"></div>
    <img id="audio-icon" src="https://img.icons8.com/ios-glyphs/30/ffffff/speaker.png" alt="Audio Icon">
    <!-- Touch Controls for Mobile Only -->
    <div id="up-arrow" class="touch-control">
        <img src="https://img.icons8.com/ios-filled/50/ffffff/up.png" class="arrow-image" alt="Up Arrow">
    </div>
    <div id="down-arrow" class="touch-control">
        <img src="https://img.icons8.com/ios-filled/50/ffffff/down.png" class="arrow-image" alt="Down Arrow">
    </div>
    <div id="left-arrow" class="touch-control">
        <img src="https://img.icons8.com/ios-filled/50/ffffff/left.png" class="arrow-image" alt="Left Arrow">
    </div>
    <div id="right-arrow" class="touch-control">
        <img src="https://img.icons8.com/ios-filled/50/ffffff/right.png" class="arrow-image" alt="Right Arrow">
    </div>
    <!-- Include Three.js library from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include FontLoader -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/jsm/loaders/FontLoader.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/examples/jsm/geometries/TextGeometry.min.js"></script>
    <!-- Main JavaScript code -->
    <script>
        // Variables
        let scene, camera, renderer;
        let character;
        let moveForward = false,
            moveBackward = false,
            rotateLeft = false,
            rotateRight = false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const portals = [];
        const objects = [];

        // Notification element
        const notification = document.getElementById('notification');
        let notificationTimeout;

        // Font Loader for retro text
        let font;

        // Audio elements
        let audio, listener, audioLoader;
        let isAudioPlaying = false; // Start with audio not playing
        const audioIcon = document.getElementById('audio-icon');

        // Pixelation Effect Variables
        let pixelRatio = 0.25;

        // Load Retro Font
        const loader = new THREE.FontLoader();
        loader.load('https://threejs.org/examples/fonts/droid/droid_sans_mono_regular.typeface.json', function (loadedFont) {
            font = loadedFont;
            init();
            animate();
        });

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x191970); // Midnight blue background
            scene.fog = new THREE.Fog(0x000000, 50, 200); // Linear fog with black color

            // Camera setup
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                1,
                1000
            );
            camera.position.set(0, 6, -15);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.imageRendering = 'pixelated';
            renderer.setPixelRatio(window.devicePixelRatio * pixelRatio);
            document.body.appendChild(renderer.domElement);

            // Ground with Flat Shading
            const groundGeometry = new THREE.PlaneGeometry(2000, 2000);
            const groundMaterial = new THREE.MeshBasicMaterial({ color: 0x004d00, flatShading: true });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            scene.add(ground);

            // Character setup
            character = createCharacter();
            character.position.set(-180, 1, -180);
            character.rotation.y = Math.PI / 4;
            scene.add(character);

            // Create Portals
            createPortals();

            // Create more complex trees
            createMoreComplexTrees();

            // Audio setup
            listener = new THREE.AudioListener();
            camera.add(listener);

            audio = new THREE.Audio(listener);

            audioLoader = new THREE.AudioLoader();
            // Load background audio (must be placed in the same directory as this HTML file)
            audioLoader.load('background.mp3', function(buffer) {
                audio.setBuffer(buffer);
                audio.setLoop(true);
                audio.setVolume(0.5);
                // Do not autoplay to comply with mobile browser policies
            }, undefined, function(err) {
                console.error('An error happened while loading the audio.');
            });

            // Audio Icon Event Listener
            audioIcon.addEventListener('click', toggleAudio);

            // Event Listeners for user interactions
            document.addEventListener('keydown', onKeyDown, false);
            document.addEventListener('keyup', onKeyUp, false);
            window.addEventListener('resize', onWindowResize, false);

            // Touch Controls for Mobile Only
            const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

            if (isMobile) {
                const upArrow = document.getElementById('up-arrow');
                const downArrow = document.getElementById('down-arrow');
                const leftArrow = document.getElementById('left-arrow');
                const rightArrow = document.getElementById('right-arrow');

                // Up Arrow - Move Forward
                upArrow.addEventListener('touchstart', function(event) {
                    event.preventDefault();
                    moveForward = true;
                }, { passive: false });
                upArrow.addEventListener('touchend', function(event) {
                    event.preventDefault();
                    moveForward = false;
                }, { passive: false });

                // Down Arrow - Move Backward
                downArrow.addEventListener('touchstart', function(event) {
                    event.preventDefault();
                    moveBackward = true;
                }, { passive: false });
                downArrow.addEventListener('touchend', function(event) {
                    event.preventDefault();
                    moveBackward = false;
                }, { passive: false });

                // Left Arrow - Rotate Left
                leftArrow.addEventListener('touchstart', function(event) {
                    event.preventDefault();
                    rotateLeft = true;
                }, { passive: false });
                leftArrow.addEventListener('touchend', function(event) {
                    event.preventDefault();
                    rotateLeft = false;
                }, { passive: false });

                // Right Arrow - Rotate Right
                rightArrow.addEventListener('touchstart', function(event) {
                    event.preventDefault();
                    rotateRight = true;
                }, { passive: false });
                rightArrow.addEventListener('touchend', function(event) {
                    event.preventDefault();
                    rotateRight = false;
                }, { passive: false });
            }

            // Ensure audio context is resumed on user interaction
            document.body.addEventListener('click', resumeAudioContext, false);
            document.body.addEventListener('touchstart', resumeAudioContext, false);
        }

        // Function to resume audio context
        function resumeAudioContext() {
            if (audio.context.state === 'suspended') {
                audio.context.resume();
            }
        }

        // Function to toggle audio on/off
        function toggleAudio() {
            resumeAudioContext(); // Ensure audio context is resumed
            if (isAudioPlaying) {
                audio.pause();
                audioIcon.src = 'https://img.icons8.com/ios-glyphs/30/ffffff/mute.png';
            } else {
                audio.play();
                audioIcon.src = 'https://img.icons8.com/ios-glyphs/30/ffffff/speaker.png';
            }
            isAudioPlaying = !isAudioPlaying;
        }

        // Function to create character
        function createCharacter() {
            const group = new THREE.Group();

            // Body with Flat Shading
            const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 2, 6);
            const bodyMaterial = new THREE.MeshBasicMaterial({
                color: 0xFF0000,
                flatShading: true
            });
            const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
            group.add(body);

            // Head with Flat Shading
            const headGeometry = new THREE.SphereGeometry(0.5, 6, 6);
            const headMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFFF00,
                flatShading: true
            });
            const head = new THREE.Mesh(headGeometry, headMaterial);
            head.position.y = 1.5;
            group.add(head);

            // Cone Hat with Flat Shading
            const hatGeometry = new THREE.ConeGeometry(0.6, 1, 4);
            const hatMaterial = new THREE.MeshBasicMaterial({ color: 0x0000FF, flatShading: true });
            const hat = new THREE.Mesh(hatGeometry, hatMaterial);
            hat.position.y = 2.3;
            group.add(hat);

            group.position.y = 1;

            // Add to objects for collision detection
            objects.push(group);

            return group;
        }

        // Function to create portals
        function createPortals() {
            const portalNames = ['SHOP', 'ABOUT', 'CONTACT', 'LOOKBOOK', 'BLOG', 'CAREERS'];
            const radius = 19.5;
            const angleIncrement = (Math.PI * 2) / 6;
            const portalColors = [0xFF0000, 0xFF7F00, 0xFFFF00, 0x00FF00, 0x0000FF, 0x8B00FF];

            for (let i = 0; i < 6; i++) {
                const angle = angleIncrement * i;
                const x = radius * Math.cos(angle);
                const z = radius * Math.sin(angle);
                const position = new THREE.Vector3(x, 0, z);

                const portalGroup = new THREE.Group();

                // Portal Frame with Flat Shading
                const frameGeometry = new THREE.BoxGeometry(5.2, 10.4, 0.65);
                const frameMaterial = new THREE.MeshBasicMaterial({ color: 0x808080, flatShading: true });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                frame.position.y = 4;
                portalGroup.add(frame);

                // Inner Portal with Flat Shading
                const innerGeometry = new THREE.PlaneGeometry(4.55, 9.75);
                const innerMaterial = new THREE.MeshBasicMaterial({
                    color: portalColors[i],
                    flatShading: true
                });
                const innerPortal = new THREE.Mesh(innerGeometry, innerMaterial);
                innerPortal.position.y = 4;
                innerPortal.position.z = 0.35;
                portalGroup.add(innerPortal);

                portalGroup.position.copy(position);

                // Calculate angle to face outward
                portalGroup.lookAt(0, 0, 0);
                portalGroup.rotateY(Math.PI);

                // Add label with Retro Font
                if (font) {
                    const textGeometry = new THREE.TextGeometry(portalNames[i], {
                        font: font,
                        size: 1.04,
                        height: 0.1,
                    });
                    const textMaterial = new THREE.MeshBasicMaterial({
                        color: 0xFFFFFF,
                        flatShading: true
                    });
                    const textMesh = new THREE.Mesh(textGeometry, textMaterial);

                    // Center the text
                    textGeometry.computeBoundingBox();
                    const textWidth = textGeometry.boundingBox.max.x - textGeometry.boundingBox.min.x;
                    textMesh.position.set(-textWidth / 2, 11.7, 0);
                    textMesh.rotation.y = 0;

                    portalGroup.add(textMesh);

                    // Add floating animation to the label
                    portals.push({
                        group: portalGroup,
                        name: portalNames[i],
                        innerPortal: innerPortal,
                        labelMesh: textMesh,
                        labelStartY: textMesh.position.y,
                    });
                } else {
                    portals.push({
                        group: portalGroup,
                        name: portalNames[i],
                        innerPortal: innerPortal,
                    });
                }

                scene.add(portalGroup);

                // Add to objects for collision detection
                objects.push(portalGroup);
            }
        }

        // Function to create more complex trees
        function createMoreComplexTrees() {
            const treeCount = 500;
            const treeRadius = 1000;
            const minDistanceFromCenter = 30;

            for (let i = 0; i < treeCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = minDistanceFromCenter + Math.random() * (treeRadius - minDistanceFromCenter);
                const x = distance * Math.cos(angle);
                const z = distance * Math.sin(angle);

                const tree = new THREE.Group();

                // Trunk
                const trunkHeight = 25 + Math.random() * 10;
                const trunkGeometry = new THREE.CylinderGeometry(1, 1.5, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshBasicMaterial({ color: 0x8B4513, flatShading: true });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2;
                tree.add(trunk);

                // Foliage - Multiple Layers of Leaves
                const foliageColors = [0x006400, 0x008000, 0x228B22];
                let foliageHeight = trunkHeight;

                for (let j = 0; j < 3; j++) {
                    const foliageGeometry = new THREE.ConeGeometry(6 - j, 9, 5);
                    const foliageMaterial = new THREE.MeshBasicMaterial({ color: foliageColors[j], flatShading: true });
                    const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                    foliage.position.y = foliageHeight + 1;
                    tree.add(foliage);
                    foliageHeight += 4;
                }

                tree.position.set(x, 0, z);
                scene.add(tree);
                objects.push(tree);
            }
        }

        // Function to handle key down events for character movement
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    rotateLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    rotateRight = true;
                    break;
            }
        }

        // Function to handle key up events to stop character movement
        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    rotateLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    rotateRight = false;
                    break;
            }
        }

        // Function to handle window resize event
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Main animation loop
        function animate() {
            requestAnimationFrame(animate);

            const currentTime = performance.now();
            const delta = (currentTime - prevTime) / 1000;

            // Implement frame rate control (20 FPS => 50ms per frame)
            const desiredFPS = 20;
            const frameInterval = 1000 / desiredFPS;
            if (currentTime - prevTime < frameInterval) {
                return;
            }

            prevTime = currentTime;

            // Movement calculations
            velocity.x = 0;
            velocity.z = 0;
            const rotationSpeed = 2.0;
            const moveSpeed = 20.0;

            // Rotate character
            if (rotateLeft) {
                character.rotation.y += rotationSpeed * delta;
            }
            if (rotateRight) {
                character.rotation.y -= rotationSpeed * delta;
            }

            // Move character forward/backward
            if (moveForward) {
                velocity.z = -moveSpeed * delta;
            }
            if (moveBackward) {
                velocity.z = moveSpeed * delta;
            }

            // Calculate movement direction
            const forward = new THREE.Vector3(0, 0, 1);
            forward.applyQuaternion(character.quaternion);
            forward.normalize();

            const moveX = forward.x * velocity.z;
            const moveZ = forward.z * velocity.z;

            // Update character's position based on movement
            character.position.x += moveX;
            character.position.z += moveZ;

            // Collision with ground boundaries
            const boundary = 100;
            character.position.x = Math.max(-boundary, Math.min(boundary, character.position.x));
            character.position.z = Math.max(-boundary, Math.min(boundary, character.position.z));

            // Update camera position to follow character rotation but maintain a fixed distance
            const cameraOffset = new THREE.Vector3(0, 7, -15);
            const offsetPosition = cameraOffset.clone().applyQuaternion(character.quaternion);
            camera.position.copy(character.position.clone().add(offsetPosition));
            camera.lookAt(character.position.x, 7, character.position.z);

            // Portal interaction and label animation
            portals.forEach(portalObj => {
                const portal = portalObj.group;
                const distance = character.position.distanceTo(portal.position);
                if (distance < 5) {
                    // Show notification if close to portal
                    showNotification(`Portal to ${portalObj.name} Triggered`);

                    // Visual effect: Change portal color for interaction feedback
                    const primaryColors = [0xFF0000, 0x00FF00, 0x0000FF];
                    const randomColor = primaryColors[Math.floor(Math.random() * primaryColors.length)];
                    portalObj.innerPortal.material.color.setHex(randomColor);
                } else {
                    portalObj.innerPortal.material.color.setHex(0xFFFFFF);
                }

                // Floating label animation (simplified)
                if (portalObj.labelMesh) {
                    portalObj.labelMesh.position.y = portalObj.labelStartY + Math.sin(currentTime * 0.002 + portalObj.group.position.x) * 0.2;
                }
            });

            renderer.render(scene, camera);
        }

        // Function to show notifications on screen
        function showNotification(message) {
            if (notificationTimeout) {
                clearTimeout(notificationTimeout);
            }
            notification.textContent = message;
            notification.style.opacity = 1;
            notificationTimeout = setTimeout(() => {
                notification.style.opacity = 0;
            }, 2000);
        }
    </script>
</body>
</html>
